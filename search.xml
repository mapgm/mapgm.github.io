<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>浅析时间复杂度与算法优化的关联关系</title>
      <link href="/2022/04/09/qian-xi-shi-jian-fu-za-du-yu-suan-fa-you-hua-de-guan-lian-guan-xi/"/>
      <url>/2022/04/09/qian-xi-shi-jian-fu-za-du-yu-suan-fa-you-hua-de-guan-lian-guan-xi/</url>
      
        <content type="html"><![CDATA[<h3 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h3><br><blockquote><p>程序设计 = 数据结构 + 算法</p></blockquote><br><p><strong>数据结构是相互之间存在一种或多种特定关系的数据元素的集合</strong></p><p>而当我们说起数据结构时，都离不开算法，而且在很多书籍中， 也都把数据结构和算法放在一起介绍</p><br><p><strong>那什么是算法呢？</strong></p><p>通俗意义来说，算法就是描述解决问题的方法，不同的问题可以有不同种的算法去解决，但是没有一个算法可以解决所有的问题，正如世界上没有包治百病的药一样<strong>qwq</strong></p><br><p>算法具有五个基本特性：</p><ol><li><p>输入：一个算法的输入可以是零个或多个：</p><p> 比如输出 “Hello World!” 的算法就不需要输入</p></li><li><p>输出：一个算法的输出必须不为零个：</p><p> 否则用这个算法干嘛捏</p></li><li><p>有穷性：指算法可以在有限的步骤内自动结束而不会无限循环，且每一个步骤在可接受的时间内完成</p><p> 不然如果一个 $O(n!)$ 的算法算完需要20年，倒是能解决问题，但黄花菜都凉了…</p></li><li><p>确定性：算法的每一个步骤都有确定的含义，不会出现二义性</p></li><li><p>可行性：算法的每一步都必须是可行的，即每一步都能通过有限次数完成</p></li></ol><br><p>我们要做的就是在不同问题中选择最适合这个问题的算法，并配以恰当的数据结构 </p><br><h3 id="例如："><a href="#例如：" class="headerlink" title="例如："></a>例如：</h3><br><p>求最大子列和问题：</p><p><a href="https://pintia.cn/problem-sets/1497448825169559552/problems/1497448917745405952">https://pintia.cn/problem-sets/1497448825169559552/problems/1497448917745405952</a></p><p>题意大意为：在 k 个整数组成的数列中，选择连续的子序列（其实不就是子串嘛），使构成的连续子序列的和最大</p><p>输入样例：</p><pre class="line-numbers language-none"><code class="language-none">6-2 11 -4 13 -5 -2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>输出样例：</p><pre class="line-numbers language-none"><code class="language-none">20<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br><p>这个问题并不难解决，我们可以显然看出的一种算法：</p><pre class="line-numbers language-none"><code class="language-none">int res = 0;for (int i = 1;i &lt;= n;i ++) // 枚举左端点{    for (int j = i;j &lt;= n;j ++) // 枚举右端点    {        int sum = 0;        for (int k = i;k &lt;= j;k ++) sum += a[k]; // 求区间内的数字和        res = max(res, sum);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><p>我们可以看出，我们简单得来的算法时间复杂度为：$O(n^3)$</p><p>当求 1000 个数字的最大子列和时，我们要大约计算 $10^9$ 次，这显然有些超时</p><br><p>我们经过<strong>慎重</strong>思考后，得出了一个优化版的算法：</p><pre class="line-numbers language-none"><code class="language-none">int res = 0;for (int i = 1;i &lt;= n;i ++){    int sum = 0;    for (int j = i;j &lt;= n;j ++)    {        sum += a[j];        res = max(res, sum);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><p>不难看出，这个算法的时间复杂度为：$O(n^2)$</p><p>看似已经很不错了，当计算 1000 个数字时，也不过要计算 $10^6$ 次</p><br><p><strong>但一个优秀的程序员在看见一个时间复杂度为： $O(n^2)$ 的算法时，总会质问自己，还可以优化到 $O(nlogn)$ 吗？</strong></p><br><p>答案是 <strong>肯定的</strong></p><br><p>我们可以采取分而治之的方式，不断划分更小的子序列，直到分成单个数字，再不断返回当前序列的最大子列和，这样的时间复杂度为：$O(nlogn)$</p><br><p>但是，这还并不是最快的算法，我们还可以使用在线处理的算法，它的时间复杂度为 $O(n)$ ：</p><pre class="line-numbers language-none"><code class="language-none">int res = 0, sum = 0;for (int i = 1;i &lt;= n;i ++){    sum += a[i];    if (sum &gt; res) res = sum;    if (sum &lt; 0) sum = 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><p>我们轻松（jian nan）的将一个 $O(n^3)$ 的算法优化到了 $O(n)$ ，时间复杂度为 $O(n)$ 的算法也是目前来说最快的了，毕竟你至少得把所有数都过一遍吧……</p><br><p>在上述例子中，我们针对一个具体的问题，不断优化算法，最终得到了一个最优的算法，也将时间复杂度降到了 $O(n)$ ，学会优化自己的代码是一件很重要且受益无穷的事</p><br><p>下次见~~</p>]]></content>
      
      
      <categories>
          
          <category> 时间复杂度 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 时间复杂度 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22/01/10 随笔</title>
      <link href="/2022/01/10/sui-bi/"/>
      <url>/2022/01/10/sui-bi/</url>
      
        <content type="html"><![CDATA[<p>ceil()上取整，在cmath库中</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++的简单容器deque</title>
      <link href="/2021/12/19/c-de-jian-dan-rong-qi-deque/"/>
      <url>/2021/12/19/c-de-jian-dan-rong-qi-deque/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;#include&lt;deque&gt;using namespace std;int main(){    deque&lt;int&gt; a[10];        a[2].push_back(2);    a[2].push_back(3);    a[2].push_back(4);    a[2].push_front(1);    a[0].push_back(2);    a[1].push_back(2);    a[9].push_back(2);        for (int i = 0;i &lt; 10;i ++)    {        if (!a[i].empty())        {            for (int j = 0;j &lt; 10;j ++)            {                cout &lt;&lt; a[i][j] &lt;&lt; ' ';            }            cout &lt;&lt; endl;        }        else        {            cout &lt;&lt; "empty" &lt;&lt; endl;        }    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> STL </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>社团工作二三事</title>
      <link href="/2021/09/23/she-tuan-gong-zuo-er-san-shi/"/>
      <url>/2021/09/23/she-tuan-gong-zuo-er-san-shi/</url>
      
        <content type="html"><![CDATA[<p>/* 本文已经SHA256加密 */</p><p>/* 本文已经SHA256加密 */</p><p>/* 本文已经SHA256加密 */</p><p>/* 本文已经SHA256加密 */</p><p>/* 本文已经SHA256加密 */</p><p>/* 本文已经SHA256加密 */</p><br><h3 id="woc"><a href="#woc" class="headerlink" title="woc"></a>woc</h3><br><p>昨天因为我在的社团（计算机协会）改革，加好友确认是否继续留在计协，我作为新当的副会长，挨个询问。</p><br><p>有的人不同意加好友和不回复这种事就不说了，关键是有个19级的大姐，上来就问我加不加分啥的。</p><br><p>我说可能有吧，她又让我别骗她，跟我扯东扯西，认识谁谁的，和上届会长副会长啥关系的。</p><br><p>明显拿19级学姐这身份跟我摆谱呢，语气真的挺不好的，说我年轻，意思没资历当副会长，</p><br> <p>给我整无语了，社团这玩意就是靠爱发电，你当会长也没啥用说实话，跟你大几有啥关系呢？</p><br><p>我以为是上届会长副会长的朋友啥的，就忍了，难受了一天，真的，我还是没啥社会经历吧，别人一讽刺一点说话就难受</p><br> <p>我们新的会长也是19级的，我寻思不给她添麻烦了，就直接找了上届会长</p><br> <p>我问他这怎么回复？并把聊天记录给他看了，他看了她的回复也挺生气的，说根本就不认识她</p><br> <p>然后上届会长问了上届的副会长，总之就是上届副会长的一个学妹，会长让我别那么不硬气，你可是副会长啊</p><br> <p>我其实以为这个人是他们朋友啥的，不想搞僵了，就服软了，而且上届会长说不加分的，这样的话</p><br><p>我直接就跟她说了没有加分，要不要留下来，她也很硬气奥，就退社团了</p><br><p>这件事给我很大的感触吧，就像上届会长说的，林子大了什么鸟都有，想用爱发电，就得承受这些折磨</p><br><p>以后调整心态，积极进取了属于是，先把爬虫搞好，再好好搞算法比赛吧~</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 学校 </tag>
            
            <tag> 社团 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>恍然大悟！静态语言和动态语言的差别</title>
      <link href="/2021/09/22/huang-ran-da-wu-jing-tai-yu-yan-he-dong-tai-yu-yan-de-chai-bie/"/>
      <url>/2021/09/22/huang-ran-da-wu-jing-tai-yu-yan-he-dong-tai-yu-yan-de-chai-bie/</url>
      
        <content type="html"><![CDATA[<h2 id="静态语言代表：C，C-，Java，C-等"><a href="#静态语言代表：C，C-，Java，C-等" class="headerlink" title="静态语言代表：C，C++，Java，C#等"></a>静态语言代表：C，C++，Java，C#等</h2><h2 id="动态语言代表：Python，Ruby等"><a href="#动态语言代表：Python，Ruby等" class="headerlink" title="动态语言代表：Python，Ruby等"></a>动态语言代表：Python，Ruby等</h2><hr><h3 id="动态语言和静态语言的区别1："><a href="#动态语言和静态语言的区别1：" class="headerlink" title="动态语言和静态语言的区别1："></a>动态语言和静态语言的区别1：</h3><br><p>静态语言是在编译时变量的数据类型即可确定的语言，多数静态类型语言要求在使用变量之前必须声明数据类型  </p><p>动态语言是在运行时确定数据类型的语言。变量使用之前不需要类型声明，通常变量的类型是被赋值的那个值的类型</p><br><p><strong>总结：静态语言使用前必须声明类型，如int a等；而动态语言可以直接使用变量a，无需提前声明</strong></p><br><h3 id="动态语言和静态语言的区别2："><a href="#动态语言和静态语言的区别2：" class="headerlink" title="动态语言和静态语言的区别2："></a>动态语言和静态语言的区别2：</h3><br><p>静态类型语言编译时会进行类型匹配检查，所以不能给变量赋予不同类型的值</p><p>动态类型语言的变量类型在运行期是可变的，这意味着对象的多态性是与生俱来的</p><br><p><strong>总结：在静态语言中，如果已经有int a，此时令a=’hello’，则会报错；而在动态语言中，即使有a=3，a的值也可以随便更改为2.343，’hello’等</strong></p><hr><h3 id="与静态语言相比，动态语言更灵活，但是静态语言比动态语言在大型项目上更安全"><a href="#与静态语言相比，动态语言更灵活，但是静态语言比动态语言在大型项目上更安全" class="headerlink" title="与静态语言相比，动态语言更灵活，但是静态语言比动态语言在大型项目上更安全"></a>与静态语言相比，动态语言更灵活，但是静态语言比动态语言在大型项目上更安全</h3>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 动态语言 </tag>
            
            <tag> 静态语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客网python刷题</title>
      <link href="/2021/09/21/niu-ke-wang-python-shua-ti/"/>
      <url>/2021/09/21/niu-ke-wang-python-shua-ti/</url>
      
        <content type="html"><![CDATA[<h3 id="1-字典是-Python-语言中唯一的映射类型，阐述了键与键值之间的对应关系。"><a href="#1-字典是-Python-语言中唯一的映射类型，阐述了键与键值之间的对应关系。" class="headerlink" title="1. 字典是 Python 语言中唯一的映射类型，阐述了键与键值之间的对应关系。"></a>1. 字典是 Python 语言中唯一的映射类型，阐述了键与键值之间的对应关系。</h3><br><h3 id="2-Python中变量无需声明，但是使用前必须赋值"><a href="#2-Python中变量无需声明，但是使用前必须赋值" class="headerlink" title="2. Python中变量无需声明，但是使用前必须赋值"></a>2. Python中变量无需声明，但是使用前必须赋值</h3><br><h3 id="3-set-为集合类型，会自动删除相同元素"><a href="#3-set-为集合类型，会自动删除相同元素" class="headerlink" title="3. set()为集合类型，会自动删除相同元素"></a>3. set()为集合类型，会自动删除相同元素</h3><br><h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><pre class="line-numbers language-none"><code class="language-none">a = 1b = aa = 2print(b) -&gt; b = 1a = [1]b = aa.append(2)print(b) -&gt; b = [1,2]a = [1]b = aa = [2]print(b) -&gt; b = [1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>如代码可知，当a和b为数字时候，a和b指向同一个内存，其值为1，所以当a改变自己的值后，无法影响b的值</strong></p><p>而当a和b都为列表，且用append向列表内添加元素时，a和b指向的内存的值由[1]改变为[1,2]，所以a和b的值均为[1,2]</p><p>当a和b都为列表时，a和b指向同一个内存，其值为[1]，所以当a改变自己的值后，无法影响b的值</p><p><strong>由此可知，当a被赋值且b = a时，改变a的值对b的值无影响，除非改变a和b同时指向的内存的值</strong></p><br><h3 id="5-将-“-1-2-3-”-变成-1-2-3-只需要eval-函数-eval-“-1-2-3-”-x3D-1-2-3"><a href="#5-将-“-1-2-3-”-变成-1-2-3-只需要eval-函数-eval-“-1-2-3-”-x3D-1-2-3" class="headerlink" title="5. 将 “[1,2,3]” 变成 [1,2,3] 只需要eval()函数       eval(“[1,2,3]”) = [1,2,3]"></a>5. 将 “[1,2,3]” 变成 [1,2,3] 只需要eval()函数       eval(“[1,2,3]”) = [1,2,3]</h3><br><h3 id="6-print-函数中可以加入sep间隔符，如-print-“XXXX”-”XXX”-”demo”-sep-x3D-”-“-就会输出-XXXX-XXX-demo-注意字符串间要有逗号才会以分隔符间断"><a href="#6-print-函数中可以加入sep间隔符，如-print-“XXXX”-”XXX”-”demo”-sep-x3D-”-“-就会输出-XXXX-XXX-demo-注意字符串间要有逗号才会以分隔符间断" class="headerlink" title="6. print()函数中可以加入sep间隔符，如 print(“XXXX”,”XXX”,”demo”,sep=”-“) 就会输出 XXXX-XXX-demo  (注意字符串间要有逗号才会以分隔符间断)"></a>6. print()函数中可以加入sep间隔符，如 print(“XXXX”,”XXX”,”demo”,sep=”-“) 就会输出 XXXX-XXX-demo  (注意字符串间要有逗号才会以分隔符间断)</h3><br> <h3 id="7-break中断的是最近的for循环或while循环"><a href="#7-break中断的是最近的for循环或while循环" class="headerlink" title="7. break中断的是最近的for循环或while循环"></a>7. break中断的是最近的for循环或while循环</h3><br><h3 id="8-没事别把变量名起成list，str，dic等，有时会引发蜜汁bug"><a href="#8-没事别把变量名起成list，str，dic等，有时会引发蜜汁bug" class="headerlink" title="8. 没事别把变量名起成list，str，dic等，有时会引发蜜汁bug"></a>8. 没事别把变量名起成list，str，dic等，有时会引发蜜汁bug</h3><br><h3 id="9-可以用-s-strip-b-x3D-x3D-‘’-来判断字符串s的字符是否在字符串b中"><a href="#9-可以用-s-strip-b-x3D-x3D-‘’-来判断字符串s的字符是否在字符串b中" class="headerlink" title="9. 可以用 s.strip(b) == ‘’ 来判断字符串s的字符是否在字符串b中"></a>9. 可以用 s.strip(b) == ‘’ 来判断字符串s的字符是否在字符串b中</h3><pre class="line-numbers language-none"><code class="language-none">s = "aedfeg"b = "abcdefg"s.strip(b) == ''<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果为True</p><br><h3 id="10-把列表中的元素重复一遍加入原列表的几种方法："><a href="#10-把列表中的元素重复一遍加入原列表的几种方法：" class="headerlink" title="10. 把列表中的元素重复一遍加入原列表的几种方法："></a>10. 把列表中的元素重复一遍加入原列表的几种方法：</h3><p>如：[1,2,3] -&gt; [1,2,3,1,2,3]</p><p>(1) <code>for i in range(len(nums)): nums.append(nums[i])</code>          </p><p>注意！！当range(len(nums))的时候，这个len值已经被固定了，不会因为在nums中添加元素而导致len(nums)变大</p><p>(2) nums + nums    列表 加 列表 </p><p>(3) nums.extend(nums)  extend()函数是在列表中添加其他列表或字典的键或集合或元组</p><br><h3 id="11-split-表示以-空格，换行-n，制表符-t-为分隔符分割字符串，返回列表"><a href="#11-split-表示以-空格，换行-n，制表符-t-为分隔符分割字符串，返回列表" class="headerlink" title="11. split()  表示以 空格，换行\n，制表符\t 为分隔符分割字符串，返回列表"></a>11. split()  表示以 空格，换行\n，制表符\t 为分隔符分割字符串，返回列表</h3><p>split(“”)  报错，错误写法</p><p>split(“ “)  表示以 空格 为分隔符分割字符串，返回列表</p><br><h3 id="12-sort-是应用在-list-上的方法，sorted-可以对所有可迭代的对象进行排序操作"><a href="#12-sort-是应用在-list-上的方法，sorted-可以对所有可迭代的对象进行排序操作" class="headerlink" title="12. sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作"></a>12. sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作</h3><p>其中  reverse – 排序规则，reverse = True 降序 ， reverse = False 升序（默认）</p><p>list.sort() 会改变 list的值，result = sorted(nums) 对nums排序不会影响nums的顺序 ，result内容是排序后的值</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 牛客网 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
