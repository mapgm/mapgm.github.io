<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>浅析时间复杂度与算法优化的关联关系</title>
      <link href="/2022/04/09/qian-xi-shi-jian-fu-za-du-yu-suan-fa-you-hua-de-guan-lian-guan-xi/"/>
      <url>/2022/04/09/qian-xi-shi-jian-fu-za-du-yu-suan-fa-you-hua-de-guan-lian-guan-xi/</url>
      
        <content type="html"><![CDATA[<h3 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h3><br><blockquote><p>程序设计 = 数据结构 + 算法</p></blockquote><br><p><strong>数据结构是相互之间存在一种或多种特定关系的数据元素的集合</strong></p><p>而当我们说起数据结构时，都离不开算法，而且在很多书籍中， 也都把数据结构和算法放在一起介绍</p><br><p><strong>那什么是算法呢？</strong></p><p>通俗意义来说，算法就是描述解决问题的方法，不同的问题可以有不同种的算法去解决，但是没有一个算法可以解决所有的问题，正如世界上没有包治百病的药一样<strong>qwq</strong></p><br><p>算法具有五个基本特性：</p><ol><li><p>输入：一个算法的输入可以是零个或多个：</p><p> 比如输出 “Hello World!” 的算法就不需要输入</p></li><li><p>输出：一个算法的输出必须不为零个：</p><p> 否则用这个算法干嘛捏</p></li><li><p>有穷性：指算法可以在有限的步骤内自动结束而不会无限循环，且每一个步骤在可接受的时间内完成</p><p> 不然如果一个 $O(n!)$ 的算法算完需要20年，倒是能解决问题，但黄花菜都凉了…</p></li><li><p>确定性：算法的每一个步骤都有确定的含义，不会出现二义性</p></li><li><p>可行性：算法的每一步都必须是可行的，即每一步都能通过有限次数完成</p></li></ol><br><p>我们要做的就是在不同问题中选择最适合这个问题的算法，并配以恰当的数据结构 </p><br><h3 id="例如："><a href="#例如：" class="headerlink" title="例如："></a>例如：</h3><br><p>求最大子列和问题：</p><p><a href="https://pintia.cn/problem-sets/1497448825169559552/problems/1497448917745405952">https://pintia.cn/problem-sets/1497448825169559552/problems/1497448917745405952</a></p><p>题意大意为：在 k 个整数组成的数列中，选择连续的子序列（其实不就是子串嘛），使构成的连续子序列的和最大</p><p>输入样例：</p><pre class="line-numbers language-none"><code class="language-none">6-2 11 -4 13 -5 -2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>输出样例：</p><pre class="line-numbers language-none"><code class="language-none">20<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br><p>这个问题并不难解决，我们可以显然看出的一种算法：</p><pre class="line-numbers language-none"><code class="language-none">int res = 0;for (int i = 1;i &lt;= n;i ++) // 枚举左端点{    for (int j = i;j &lt;= n;j ++) // 枚举右端点    {        int sum = 0;        for (int k = i;k &lt;= j;k ++) sum += a[k]; // 求区间内的数字和        res = max(res, sum);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><p>我们可以看出，我们简单得来的算法时间复杂度为：$O(n^3)$</p><p>当求 1000 个数字的最大子列和时，我们要大约计算 $10^9$ 次，这显然有些超时</p><br><p>我们经过<strong>慎重</strong>思考后，得出了一个优化版的算法：</p><pre class="line-numbers language-none"><code class="language-none">int res = 0;for (int i = 1;i &lt;= n;i ++){    int sum = 0;    for (int j = i;j &lt;= n;j ++)    {        sum += a[j];        res = max(res, sum);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><p>不难看出，这个算法的时间复杂度为：$O(n^2)$</p><p>看似已经很不错了，当计算 1000 个数字时，也不过要计算 $10^6$ 次</p><br><p><strong>但一个优秀的程序员在看见一个时间复杂度为： $O(n^2)$ 的算法时，总会质问自己，还可以优化到 $O(nlogn)$ 吗？</strong></p><br><p>答案是 <strong>肯定的</strong></p><br><p>我们可以采取分而治之的方式，不断划分更小的子序列，直到分成单个数字，再不断返回当前序列的最大子列和，这样的时间复杂度为：$O(nlogn)$</p><br><p>但是，这还并不是最快的算法，我们还可以使用在线处理的算法，它的时间复杂度为 $O(n)$ ：</p><pre class="line-numbers language-none"><code class="language-none">int res = 0, sum = 0;for (int i = 1;i &lt;= n;i ++){    sum += a[i];    if (sum &gt; res) res = sum;    if (sum &lt; 0) sum = 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><p>我们轻松（jian nan）的将一个 $O(n^3)$ 的算法优化到了 $O(n)$ ，时间复杂度为 $O(n)$ 的算法也是目前来说最快的了，毕竟你至少得把所有数都过一遍吧……</p><br><p>在上述例子中，我们针对一个具体的问题，不断优化算法，最终得到了一个最优的算法，也将时间复杂度降到了 $O(n)$ ，学会优化自己的代码是一件很重要且受益无穷的事</p><br><p>下次见~~</p>]]></content>
      
      
      <categories>
          
          <category> 时间复杂度 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 时间复杂度 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>恍然大悟！静态语言和动态语言的差别</title>
      <link href="/2021/09/22/huang-ran-da-wu-jing-tai-yu-yan-he-dong-tai-yu-yan-de-chai-bie/"/>
      <url>/2021/09/22/huang-ran-da-wu-jing-tai-yu-yan-he-dong-tai-yu-yan-de-chai-bie/</url>
      
        <content type="html"><![CDATA[<h2 id="静态语言代表：C，C-，Java，C-等"><a href="#静态语言代表：C，C-，Java，C-等" class="headerlink" title="静态语言代表：C，C++，Java，C#等"></a>静态语言代表：C，C++，Java，C#等</h2><h2 id="动态语言代表：Python，Ruby等"><a href="#动态语言代表：Python，Ruby等" class="headerlink" title="动态语言代表：Python，Ruby等"></a>动态语言代表：Python，Ruby等</h2><hr><h3 id="动态语言和静态语言的区别1："><a href="#动态语言和静态语言的区别1：" class="headerlink" title="动态语言和静态语言的区别1："></a>动态语言和静态语言的区别1：</h3><br><p>静态语言是在编译时变量的数据类型即可确定的语言，多数静态类型语言要求在使用变量之前必须声明数据类型  </p><p>动态语言是在运行时确定数据类型的语言。变量使用之前不需要类型声明，通常变量的类型是被赋值的那个值的类型</p><br><p><strong>总结：静态语言使用前必须声明类型，如int a等；而动态语言可以直接使用变量a，无需提前声明</strong></p><br><h3 id="动态语言和静态语言的区别2："><a href="#动态语言和静态语言的区别2：" class="headerlink" title="动态语言和静态语言的区别2："></a>动态语言和静态语言的区别2：</h3><br><p>静态类型语言编译时会进行类型匹配检查，所以不能给变量赋予不同类型的值</p><p>动态类型语言的变量类型在运行期是可变的，这意味着对象的多态性是与生俱来的</p><br><p><strong>总结：在静态语言中，如果已经有int a，此时令a=’hello’，则会报错；而在动态语言中，即使有a=3，a的值也可以随便更改为2.343，’hello’等</strong></p><hr><h3 id="与静态语言相比，动态语言更灵活，但是静态语言比动态语言在大型项目上更安全"><a href="#与静态语言相比，动态语言更灵活，但是静态语言比动态语言在大型项目上更安全" class="headerlink" title="与静态语言相比，动态语言更灵活，但是静态语言比动态语言在大型项目上更安全"></a>与静态语言相比，动态语言更灵活，但是静态语言比动态语言在大型项目上更安全</h3>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 动态语言 </tag>
            
            <tag> 静态语言 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
